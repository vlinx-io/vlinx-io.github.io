(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[340],{9022:function(n,a,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/extract-java-classes-information-from-aot",function(){return s(6527)}])},6527:function(n,a,s){"use strict";s.r(a),s.d(a,{__N_SSG:function(){return t}});var e=s(5893),i=s(1151);function r(n){let a=Object.assign({h1:"h1",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",a:"a"},(0,i.ah)(),n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(a.h1,{children:"从AOT编译的二进制文件中提取Java类信息"}),"\n",(0,e.jsx)(a.p,{children:"AOT编译是Java世界讨论已久的话题，但直到GraalVM出现之前没有工具能够实现较好的AOT编译，更不用说驱动整个生态系统。尽管GraalVM提供了可以有效帮助开发者进行AOT编译的native-image工具，但由于Java生态系统的复杂性和多样性，要实现Java应用程序的开箱即用的AOT编译仍然非常困难，尤其是反射和代理技术在各种常见框架中被广泛使用。"}),"\n",(0,e.jsx)(a.h2,{id:"spring-native",children:"Spring Native 项目"}),"\n",(0,e.jsx)(a.p,{children:"感谢Spring框架团队的Spring Native项目，他们可以通过Maven或Gradle插件实现项目的一键AOT编译。当然，目前只适用于Spring Boot项目。"}),"\n",(0,e.jsx)(a.p,{children:"请使用Sping Native生成AOT编译的Java程序"}),"\n",(0,e.jsx)(a.p,{children:"以下是官方Spring Native示例，用于生成AOT编译的Java应用程序（测试环境：Ubuntu 20.04，Docker 20.10.6）"}),"\n",(0,e.jsx)(a.pre,{language:"bash",code:"git clone https://github.com/spring-projects-experimental/spring-native.git\ncd spring-native/sample/petclinic-jpa\n./build.sh\n",children:(0,e.jsx)(a.code,{className:"language-bash",children:'<span><span style="color: var(--shiki-color-text)">git clone https://github.com/spring-projects-experimental/spring-native.git</span></span>\n<span><span style="color: var(--shiki-token-function)">cd</span><span style="color: var(--shiki-color-text)"> spring-native/sample/petclinic-jpa</span></span>\n<span><span style="color: var(--shiki-color-text)">./build.sh</span></span>\n<span></span>'})}),"\n",(0,e.jsx)(a.p,{children:"在相对较长的编译时间和大量的内存消耗后，我们可以在目标目录中得到AOT编译的Java程序，这是一个独立的二进制文件，可以独立运行，无需任何依赖。"}),"\n",(0,e.jsx)(a.p,{children:(0,e.jsx)(a.img,{src:"https://vlinx.io/resources/images/1*SkManKjiTyBZwwfQeyNOJQ.png",alt:"img"})}),"\n",(0,e.jsx)(a.p,{children:"petclinic-jpa是由AOT编译的程序，可以直接运行"}),"\n",(0,e.jsx)(a.h2,{id:"aot-java",children:"从AOT编译的二进制文件中提取Java类信息"}),"\n",(0,e.jsx)(a.p,{children:"Java代码保护在过去一直是一个非常困难的问题，AOT也被认为是Java代码保护的一种解决方案，但不幸的是，现在的许多Java程序无法与框架分离，由于框架的复杂性，即使是由AOT编译的程序也必须将类信息包含到最终生成的二进制文件中，而类文件实际上是整齐地排列在二进制文件的资源区域中。"}),"\n",(0,e.jsx)(a.p,{children:"以下工具可以扫描并从AOT编译的二进制文件中提取类信息"}),"\n",(0,e.jsx)(a.p,{children:(0,e.jsx)(a.a,{href:"https://github.com/3-keys/binary-classfile-reader",children:"https://github.com/3-keys/binary-classfile-reader"})}),"\n",(0,e.jsx)(a.pre,{language:"bash",code:"git clone https://github.com/3-keys/binary-classfile-reader\ncd binary-classfile-reader\n./gradlew run --args='&lt;path-of-the-binary-file&gt; &lt;output-folder&gt;'\n",children:(0,e.jsx)(a.code,{className:"language-bash",children:'<span><span style="color: var(--shiki-color-text)">git clone https://github.com/3-keys/binary-classfile-reader</span></span>\n<span><span style="color: var(--shiki-token-function)">cd</span><span style="color: var(--shiki-color-text)"> binary-classfile-reader</span></span>\n<span><span style="color: var(--shiki-color-text)">./gradlew run --args=</span><span style="color: var(--shiki-token-string-expression)">&#39;&amp;lt;path-of-the-binary-file&amp;gt; &amp;lt;output-folder&amp;gt;&#39;</span></span>\n<span></span>'})}),"\n",(0,e.jsx)(a.p,{children:"将上一步获得的petclinic-jpa作为例子，从中提取类信息，与源代码进行比较，你可以看到，模型信息，控制器信息，和服务信息都可以获得。"}),"\n",(0,e.jsx)(a.p,{children:(0,e.jsx)(a.img,{src:"https://vlinx.io/resources/images/1*VlKHd02LdN-_EyNfT1Mquw.png",alt:"img"})})]})}var t=!0;a.default=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,i.ah)(),n.components);return a?(0,e.jsx)(a,Object.assign({},n,{children:(0,e.jsx)(r,n)})):r(n)}}},function(n){n.O(0,[774,888,179],function(){return n(n.s=9022)}),_N_E=n.O()}]);