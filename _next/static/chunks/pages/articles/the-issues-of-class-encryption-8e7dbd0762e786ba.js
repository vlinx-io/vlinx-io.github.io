(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[505],{4443:function(n,s,e){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/the-issues-of-class-encryption",function(){return e(913)}])},913:function(n,s,e){"use strict";e.r(s),e.d(s,{__N_SSG:function(){return i}});var t=e(5893),c=e(1151);function r(n){let s=Object.assign({h1:"h1",p:"p",h2:"h2",a:"a"},(0,c.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{children:"Java类文件加密存在的问题"}),"\n",(0,t.jsx)(s.p,{children:"除了混淆之外，类文件加密是一种很容易被想到的代码保护方式，许多方案采用agent的方式对类文件进行加密，并在类加载的时候解密。但这些方案都忽略了很重要的一点，即JVM自带的附加机制"}),"\n",(0,t.jsx)(s.h2,{id:"jvm",children:"JVM附加机制"}),"\n",(0,t.jsx)(s.p,{children:"为了便于对程序的运行状况进行分析与监测，普通的JVM都带有附加自制，用户可以使用jhsdb这类工具，附加到JVM进程，对其内存数据进行查看和分析，并且这些内存数据还是按照源文件中的数据结构被妥善组织好的，这也可以理解为JVM自带的一种后门机制。"}),"\n",(0,t.jsx)(s.p,{children:"下面这篇文章介绍了如何使用JVM附加机制读取并保存内存中的类文件信息"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"https://protector4j.com/articles/cracking-encrypted-java-applications-jhsdb/",children:"https://protector4j.com/articles/cracking-encrypted-java-applications-jhsdb/"})}),"\n",(0,t.jsxs)(s.p,{children:["除了可以使用JDK自带的jhsdb工具之外，还可以使用阿里巴巴的",(0,t.jsx)(s.a,{href:"https://github.com/alibaba/arthas",children:"Arthas"}),"对运行中的Java进程进行分析。"]}),"\n",(0,t.jsx)(s.h2,{id:"",children:"结论"}),"\n",(0,t.jsx)(s.p,{children:"由于JVM附加机制的存在，所有未脱离普通JVM运行的所谓加密代码，都可以使用附加工具轻松读取，因此这是一种最无效的保护方案。"})]})}var i=!0;s.default=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,c.ah)(),n.components);return s?(0,t.jsx)(s,Object.assign({},n,{children:(0,t.jsx)(r,n)})):r(n)}}},function(n){n.O(0,[774,888,179],function(){return n(n.s=4443)}),_N_E=n.O()}]);