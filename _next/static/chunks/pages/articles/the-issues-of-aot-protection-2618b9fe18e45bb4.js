(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[86],{6504:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/the-issues-of-aot-protection",function(){return t(9998)}])},9998:function(e,n,t){"use strict";t.r(n),t.d(n,{__N_SSG:function(){return i}});var r=t(5893),a=t(1151);function s(e){let n=Object.assign({h1:"h1",p:"p",a:"a",h2:"h2"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{children:"AOT编译存在的问题"}),"\n",(0,r.jsx)(n.p,{children:"AOT编译即将Java代码编码为本地代码，不仅大大提高了Java程序的运行速度，而且由于将Java代码转换为机器代码，因此也间接达到了保护Java代码的目的。"}),"\n",(0,r.jsxs)(n.p,{children:["对于Java程序来说，特别对于基于各类框架的Java程序，由于包含了许多动态特性，进行AOT编译是一个巨大的挑战，同时为了向动态性做出妥协，编译完成后的二进制文件中仍然可能包含大量类文件信息。下面这篇文章即介绍了一个项目，通过扫描编译好的二进制文件获取到类信息\n",(0,r.jsx)(n.a,{href:"https://protector4j.com/articles/extract-java-classes-information-from-aot/",children:"https://protector4j.com/articles/extract-java-classes-information-from-aot/"})]}),"\n",(0,r.jsx)(n.p,{children:"即使二进制程序中不包含类文件信息，但是其运行逻辑仍然是同样存在的，只不过表示形式由原来的字节码表示转换为机器代码表示，并没有进行特别的保护，如果能够了解其本身的编译与运行机制，仍然能够逆向还原出可读性的代码。下面这篇文章即介绍了这样一个项目"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://protector4j.com/articles/graalvm-nativeimage-reverse-engineering/",children:"https://protector4j.com/articles/graalvm-nativeimage-reverse-engineering/"})}),"\n",(0,r.jsx)(n.h2,{id:"",children:"结论"}),"\n",(0,r.jsx)(n.p,{children:"AOT编译配置难度大，编译难度大，编译失败概率高，即使编译成功，代码逻辑也仅是由原来的字节码表示转换为机器代码表示，其本身的运行逻辑仍然存在，并没有进行特别的保护，如果能够了解其本身的编译与运行机制，仍然能够逆向还原出可读性的代码。"})]})}var i=!0;n.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(s,e)})):s(e)}}},function(e){e.O(0,[774,888,179],function(){return e(e.s=6504)}),_N_E=e.O()}]);