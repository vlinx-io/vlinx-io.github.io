(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[340],{9022:function(e,a,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/extract-java-classes-information-from-aot",function(){return n(6527)}])},6527:function(e,a,n){"use strict";n.r(a),n.d(a,{__N_SSG:function(){return r}});var i=n(5893),t=n(1151);function o(e){let a=Object.assign({h1:"h1",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",a:"a"},(0,t.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.h1,{children:"Extract Java classes information from AOT compiled binary file"}),"\n",(0,i.jsx)(a.p,{children:"AOT compilation is a topic that has been discussed in the Java world for a long time, but until GraalVM appeared, there was no tool that could achieve a better AOT compilation, let alone drive the whole ecosystem. Although GraalVM provides the native-image tool that can effectively help developers perform AOT compilation, it is still very difficult to achieve an out-of-the-box AOT compilation for Java applications due to the complexity and diversity of the Java ecosystem, especially since reflection and proxy technologies are widely used in various common frameworks."}),"\n",(0,i.jsx)(a.h2,{id:"spring-native-project",children:"Spring Native Project"}),"\n",(0,i.jsx)(a.p,{children:"Thanks to the Spring Native project from the Spring framework team, they can achieve a one-click AOT compilation of the project through Maven or Gradle plug-ins. Of course, it is currently only available for Spring Boot projects."}),"\n",(0,i.jsx)(a.h2,{id:"use-sping-native-to-generate-aot-compiled-java-programs",children:"Use Sping Native to generate AOT compiled Java programs"}),"\n",(0,i.jsx)(a.p,{children:"Here is the official Spring Native example to generate an AOT-compiled Java application (test environment: Ubuntu 20.04, Docker 20.10.6)"}),"\n",(0,i.jsx)(a.pre,{language:"bash",code:"git clone https://github.com/spring-projects-experimental/spring-native.git\ncd spring-native/sample/petclinic-jpa\n./build.sh\n",children:(0,i.jsx)(a.code,{className:"language-bash",children:'<span><span style="color: var(--shiki-color-text)">git clone https://github.com/spring-projects-experimental/spring-native.git</span></span>\n<span><span style="color: var(--shiki-token-function)">cd</span><span style="color: var(--shiki-color-text)"> spring-native/sample/petclinic-jpa</span></span>\n<span><span style="color: var(--shiki-color-text)">./build.sh</span></span>\n<span></span>'})}),"\n",(0,i.jsx)(a.p,{children:"After a relatively long compilation time and a lot of memory consumption, we can get the AOT compiled Java program in the target directory, which is a standalone binary and can run independently without any dependencies."}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{src:"https://vlinx.io/resources/images/1*SkManKjiTyBZwwfQeyNOJQ.png",alt:"img"})}),"\n",(0,i.jsx)(a.p,{children:"petclinic-jpa is the program compiled by AOT and can be run directly"}),"\n",(0,i.jsx)(a.h2,{id:"extract-java-classes-information-from-aot-compiled-binary-file",children:"Extract Java classes information from AOT compiled binary file"}),"\n",(0,i.jsx)(a.p,{children:"Java code protection has been a very difficult problem in the past, and AOT is also considered a solution for Java code protection, but unfortunately, many Java programs nowadays cannot be separated from the framework, and due to the complexity of the framework, even programs compiled by AOT have to include class information into the final generated binary file, and the class files are actually neatly arranged in the resources area of the binary file."}),"\n",(0,i.jsx)(a.p,{children:"The following tool can scan and extract class information from AOT compiled binary files"}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.a,{href:"https://github.com/3-keys/binary-classfile-reader",children:"https://github.com/3-keys/binary-classfile-reader"})}),"\n",(0,i.jsx)(a.pre,{language:"bash",code:"git clone https://github.com/3-keys/binary-classfile-reader\ncd binary-classfile-reader\n./gradlew run --args='&lt;path-of-the-binary-file&gt; &lt;output-folder&gt;'\n",children:(0,i.jsx)(a.code,{className:"language-bash",children:'<span><span style="color: var(--shiki-color-text)">git clone https://github.com/3-keys/binary-classfile-reader</span></span>\n<span><span style="color: var(--shiki-token-function)">cd</span><span style="color: var(--shiki-color-text)"> binary-classfile-reader</span></span>\n<span><span style="color: var(--shiki-color-text)">./gradlew run --args=</span><span style="color: var(--shiki-token-string-expression)">&#39;&amp;lt;path-of-the-binary-file&amp;gt; &amp;lt;output-folder&amp;gt;&#39;</span></span>\n<span></span>'})}),"\n",(0,i.jsx)(a.p,{children:"Take the petclinic-jpa obtained in the previous step as an example, extract the class information from it, compare it with the source code, and you can see that Model information, Controller information, and Service information can all be obtained."}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{src:"https://vlinx.io/resources/images/1*VlKHd02LdN-_EyNfT1Mquw.png",alt:"img"})})]})}var r=!0;a.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,t.ah)(),e.components);return a?(0,i.jsx)(a,Object.assign({},e,{children:(0,i.jsx)(o,e)})):o(e)}}},function(e){e.O(0,[774,888,179],function(){return e(e.s=9022)}),_N_E=e.O()}]);