(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[988],{438:function(n,r,e){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/protecting-java-source-code-beyond-obfuscation",function(){return e(2663)}])},2663:function(n,r,e){"use strict";e.r(r),e.d(r,{__N_SSG:function(){return s}});var a=e(5893),c=e(1151);function t(n){let r=Object.assign({h1:"h1",p:"p",h2:"h2"},(0,c.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h1,{children:"保护Java源代码超越混淆"}),"\n",(0,a.jsx)(r.p,{children:"Java类文件很容易被反向工程化。使Java应用程序能在任何地方运行的那些属性，使反向翻译变得直接。"}),"\n",(0,a.jsx)(r.p,{children:"市场上有许多Java反编译器，它们可以生成令人惊讶的易读源代码。任何具有一般编程技能的人都可以下载Java反编译器，通过它运行你的应用程序，并几乎像阅读开源代码一样阅读源代码。"}),"\n",(0,a.jsx)(r.h2,{id:"",children:"混淆"}),"\n",(0,a.jsx)(r.p,{children:"一个混淆器可以使反编译的代码变得难以理解。然而，名称混淆可能会导致反射和JNI失败，而大量的控制流混淆则会对性能产生负面影响，并可能引发VerifyError。更糟糕的是，这些问题只有在相应的类实际在应用程序运行时加载时才会显现出来，因此可能会在QA过程中被忽视。并且，通过优化编译器处理的等效C++程序的逆向工程仍然会更困难。"}),"\n",(0,a.jsx)(r.h2,{id:"protector4-j",children:"通过Protector4J加强保护"}),"\n",(0,a.jsx)(r.p,{children:"Protector4J可以通过加密类来保护您的java源代码，它通过修改JVM创建了一个自定义的本地ClassLoader。Java类由AES加密，并在本地ClassLoader中解密。并且它还引入了一些机制来提高破解的难度。"}),"\n",(0,a.jsx)(r.p,{children:"加密您的代码可以保护您的知识产权，并大大提高您的应用程序的安全性。它使得IP盗窃、代码篡改和安全漏洞的发现涉及到昂贵的逆向工程努力，而实际上任何人都可以下载并运行一个免费的Java反编译器。"}),"\n",(0,a.jsx)(r.p,{children:"Protector4J也可以帮助您为Windows，Linux，macOS创建您的Java App的可执行包装器"})]})}var s=!0;r.default=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.ah)(),n.components);return r?(0,a.jsx)(r,Object.assign({},n,{children:(0,a.jsx)(t,n)})):t(n)}}},function(n){n.O(0,[774,888,179],function(){return n(n.s=438)}),_N_E=n.O()}]);